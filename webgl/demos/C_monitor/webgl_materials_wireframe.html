<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - materials - wireframe</title>
		<meta charset="utf-8">
		<style>
			body {
				margin: 0px;
				background-color: #000000;
				overflow: hidden;
			}
		</style>
	</head>
	<body>

		<script src="js/lib/three.min.r53.js" type="text/javascript" charset="utf-8"></script>

		<script type="x-shader/x-vertex" id="vertexShader">

			attribute vec4 center;
			varying vec4 vCenter;

			void main() {

				vCenter = center;
				gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

			}

		</script>

		<script type="x-shader/x-fragment" id="fragmentShader">

			#extension GL_OES_standard_derivatives : enable

			varying vec4 vCenter;

			float edgeFactorTri() {

				vec3 d = fwidth( vCenter.xyz );
				vec3 a3 = smoothstep( vec3( 0.0 ), d * 1.5, vCenter.xyz );
				return min( min( a3.x, a3.y ), a3.z );

			}

			float edgeFactorQuad1() {

				vec2 d = fwidth( vCenter.xy );
				vec2 a2 = smoothstep( vec2( 0.0 ), d * 1.5, vCenter.xy );

				return min( a2.x, a2.y );

			}

			float edgeFactorQuad2() {

				vec2 d = fwidth( 1.0 - vCenter.xy );
				vec2 a2 = smoothstep( vec2( 0.0 ), d * 1.5, 1.0 - vCenter.xy );

				return min( a2.x, a2.y );
			}

			void main() {

				if ( vCenter.w == 0.0 ) {

					//gl_FragColor.rgb = mix( vec3( 1,1,1 ), vec3( 1,1,1 ), edgeFactorTri() );
					gl_FragColor.rgb = vec3( 0.48,0.64,0.48 );

				} else {

					//gl_FragColor.rgb = mix( vec3( 1,0,0 ), vec3( 1,0,0 ), min( edgeFactorQuad1(), edgeFactorQuad2() ) );
					gl_FragColor.rgb = vec3( 1,0,0 );

				}
                gl_FragColor.a = 1.0;
				

			}

		</script>

		<script>

			var camera, scene, renderer;
			var meshQuads;

			init();
			animate();

			function init() {

				camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 2000 );
				camera.position.z = 800;

				scene = new THREE.Scene();
                
                
                var loader = new THREE.JSONLoader();
                
                loader.load( 'js/china_model.js', function ( geometryQuads) {
                    
                    var vertexShader = document.getElementById( 'vertexShader' ).textContent;
                    var fragmentShader = document.getElementById( 'fragmentShader' ).textContent;
    
                    // wireframe using gl.TRIANGLES (interpreted as quads)
    
                    var attributesQuads = { center: { type: 'v4', boundTo: 'faceVertices', value: [] } };
                    var valuesQuads = attributesQuads.center.value;
    
                    setupAttributes( geometryQuads, valuesQuads );
    
                    var materialQuads = new THREE.ShaderMaterial( { uniforms: {}, attributes: attributesQuads, vertexShader: vertexShader, fragmentShader: fragmentShader } );
    
                    meshQuads = new THREE.Mesh( geometryQuads, materialQuads );
                    meshQuads.position.x = 0;
                    meshQuads.scale.set( 30, 30, 10);
                    scene.add( meshQuads );
                    
                });
                
                
                /*
				var size = 150;

				var geometryQuads = new THREE.CubeGeometry( size, size, size );


				//

				var vertexShader = document.getElementById( 'vertexShader' ).textContent;
				var fragmentShader = document.getElementById( 'fragmentShader' ).textContent;

				// wireframe using gl.TRIANGLES (interpreted as quads)

				var attributesQuads = { center: { type: 'v4', boundTo: 'faceVertices', value: [] } };
				var valuesQuads = attributesQuads.center.value;

				setupAttributes( geometryQuads, valuesQuads );

				var materialQuads = new THREE.ShaderMaterial( { uniforms: {}, attributes: attributesQuads, vertexShader: vertexShader, fragmentShader: fragmentShader } );

				meshQuads = new THREE.Mesh( geometryQuads, materialQuads );
				meshQuads.position.x = 300;
				scene.add( meshQuads );
				*/


				


				// renderer

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );

				// events

				window.addEventListener( 'resize', onWindowResize, false );

			}

			function setupAttributes( geometry, values ) {

				for( var f = 0; f < geometry.faces.length; f ++ ) {

					var face = geometry.faces[ f ];

					if ( face instanceof THREE.Face3 ) {

						values[ f ] = [ new THREE.Vector4( 1, 0, 0, 0 ), new THREE.Vector4( 0, 1, 0, 0 ), new THREE.Vector4( 0, 0, 1, 0 ) ];

					} else {
                        //console.info(face.normal.z);
                        if(face.normal.z != 0){
                            values[ f ] = [ new THREE.Vector4( 1, 0, 0, 0 ), new THREE.Vector4( 1, 1, 0, 0 ), new THREE.Vector4( 0, 1, 0, 0 ), new THREE.Vector4( 0, 0, 0, 0 ) ];
                        }
						else{
						    values[ f ] = [ new THREE.Vector4( 1, 0, 0, 1 ), new THREE.Vector4( 1, 1, 0, 1 ), new THREE.Vector4( 0, 1, 0, 1 ), new THREE.Vector4( 0, 0, 0, 1 ) ];
						}
						
					}

				}

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				requestAnimationFrame( animate );

                meshQuads.rotation.x += 0.005;
				//meshQuads.rotation.y += 0.01;



				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>
